# Execution
RUN_MODE=excel                 # options: excel, runList, suite

# Browser
BROWSER=chromium
HEADLESS=true

# Reporting
ALLURE_ENABLED=yes
ALLURE_RESULTS=./allure-results
ALLURE_REPORT=C:/Reports/Allure
ALLURE_AUTOOPEN=yes
ALLURE_ZIP=yes

JUNIT_ENABLED=yes
HTML_REPORT=yes

# Other settings
ENVIRONMENT=qa
BASE_URL=https://qa.example.com
RETRIES=1
TIMEOUT=30000




import { defineConfig } from '@playwright/test';
import * as dotenv from 'dotenv';
dotenv.config({ path: './config/.env' });  // Load env

export default defineConfig({
  testDir: './tests',
  timeout: parseInt(process.env.TIMEOUT || '30000'),
  retries: parseInt(process.env.RETRIES || '0'),
  use: {
    browserName: process.env.BROWSER || 'chromium',
    headless: process.env.HEADLESS === 'true',
    trace: 'on-first-retry',
    screenshot: 'only-on-failure',
    video: 'retain-on-failure',
  },
  reporter: [
    ['line'],
    ['junit', { outputFile: 'junit-report/results.xml', outputFileTemplate: '{test}.xml', includeConsoleOutput: true }],
    ['html', { outputFolder: 'html-report', open: 'never' }],
    ['allure-playwright'],
  ],
  globalTeardown: require.resolve('./utils/globalTeardown.ts'),
});



import * as dotenv from 'dotenv';
import { execSync } from 'child_process';
import fs from 'fs';
import archiver from 'archiver';
import path from 'path';

dotenv.config({ path: './config/.env' });

export default async function globalTeardown() {
  console.log('\nüöÄ Global teardown started...');

  const IS_ALLURE_ENABLED = process.env.ALLURE_ENABLED === 'yes';
  const IS_JUNIT_ENABLED = process.env.JUNIT_ENABLED === 'yes';
  const IS_HTML_ENABLED = process.env.HTML_REPORT === 'yes';
  const ALLURE_RESULTS = process.env.ALLURE_RESULTS || './allure-results';
  const ALLURE_REPORT = process.env.ALLURE_REPORT || './allure-report';
  const ALLURE_AUTOOPEN = process.env.ALLURE_AUTOOPEN === 'yes';
  const ALLURE_ZIP = process.env.ALLURE_ZIP === 'yes';

  try {
    // ---------- Allure ----------
    if (IS_ALLURE_ENABLED) {
      console.log('üìä Generating Allure Report...');
      execSync(`npx allure generate ${ALLURE_RESULTS} --clean -o "${ALLURE_REPORT}"`, { stdio: 'inherit' });
      console.log(`‚úÖ Allure Report generated at ${ALLURE_REPORT}`);

      if (ALLURE_AUTOOPEN) {
        console.log('üåê Opening Allure Report in default browser...');
        execSync(`npx allure open "${ALLURE_REPORT}"`, { stdio: 'inherit' });
      }

      if (ALLURE_ZIP) {
        const outputZip = path.resolve(`${ALLURE_REPORT}.zip`);
        const output = fs.createWriteStream(outputZip);
        const archive = archiver('zip', { zlib: { level: 9 } });
        archive.pipe(output);
        archive.directory(ALLURE_REPORT, false);
        await archive.finalize();
        console.log(`üì¶ Allure report zipped at ${outputZip}`);
      }
    }

    // ---------- JUnit ----------
    if (IS_JUNIT_ENABLED) {
      console.log('üìÑ JUnit report already generated by Playwright reporter in ./junit-report/');
    }

    // ---------- HTML ----------
    if (IS_HTML_ENABLED) {
      console.log('üåê HTML report already generated by Playwright reporter in ./html-report/');
    }

  } catch (error) {
    console.error('‚ùå Error in global teardown:', error);
  }

  console.log('üõ†Ô∏è Global teardown completed!');
}



import * as dotenv from 'dotenv';
import { execSync } from 'child_process';
import fs from 'fs-extra';
import path from 'path';
import archiver from 'archiver';

dotenv.config({ path: path.resolve(__dirname, '../config/.env') });

export default async function globalTeardown() {
  console.log('\nüöÄ Global teardown started...');

  const IS_ALLURE_ENABLED = process.env.ALLURE_ENABLED === 'yes';
  const ALLURE_RESULTS = path.resolve(process.env.ALLURE_RESULTS || './allure-results');
  const ALLURE_REPORT = path.resolve(process.env.ALLURE_REPORT || './allure-report');
  const ALLURE_AUTOOPEN = process.env.ALLURE_AUTOOPEN === 'yes';
  const ALLURE_ZIP = process.env.ALLURE_ZIP === 'yes';

  try {
    if (IS_ALLURE_ENABLED) {
      console.log(`üìä Generating Allure Report from results at: ${ALLURE_RESULTS}`);

      if (!fs.existsSync(ALLURE_RESULTS)) {
        console.warn(`‚ö†Ô∏è Allure results folder not found: ${ALLURE_RESULTS}`);
        return;
      }

      // Backup old report instead of deleting
      if (fs.existsSync(ALLURE_REPORT)) {
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const backupReport = `${ALLURE_REPORT}_${timestamp}`;
        fs.renameSync(ALLURE_REPORT, backupReport);
        console.log(`üóÇÔ∏è Backed up previous Allure report to: ${backupReport}`);
      }

      // Temporary copy results to same drive as report (prevents 404)
      const tempResults = path.join(path.dirname(ALLURE_REPORT), 'temp-allure-results');
      fs.copySync(ALLURE_RESULTS, tempResults);

      // Generate report
      execSync(`npx allure generate "${tempResults}" --clean -o "${ALLURE_REPORT}"`, { stdio: 'inherit' });
      console.log(`‚úÖ Allure report generated at: ${ALLURE_REPORT}`);

      // Auto-open in browser
      if (ALLURE_AUTOOPEN) {
        console.log('üåê Opening Allure report in default browser...');
        execSync(`npx allure open "${ALLURE_REPORT}"`, { stdio: 'inherit' });
      }

      // Zip report
      if (ALLURE_ZIP) {
        const outputZip = path.resolve(`${ALLURE_REPORT}.zip`);
        const output = fs.createWriteStream(outputZip);
        const archive = archiver('zip', { zlib: { level: 9 } });
        archive.pipe(output);
        archive.directory(ALLURE_REPORT, false);
        await archive.finalize();
        console.log(`üì¶ Allure report zipped at: ${outputZip}`);
      }

      // Clean temporary results
      fs.removeSync(tempResults);
    }

    console.log('üõ†Ô∏è Global teardown completed!');
  } catch (error) {
    console.error('‚ùå Error in global teardown:', error);
  }
}


ALLURE_ENABLED=yes
ALLURE_RESULTS=./allure-results          # results folder in project root
ALLURE_REPORT=C:/Reports/Allure          # HTML report output folder
ALLURE_AUTOOPEN=yes
ALLURE_ZIP=yes
JUNIT_ENABLED=yes
HTML_REPORT=yes


import * as dotenv from 'dotenv';
import { execSync } from 'child_process';
import fs from 'fs-extra';
import path from 'path';
import archiver from 'archiver';

dotenv.config({ path: path.resolve(__dirname, '../config/.env') });

export default async function globalTeardown() {
  console.log('\nüöÄ Global teardown started...');

  const IS_ALLURE_ENABLED = process.env.ALLURE_ENABLED === 'yes';
  const ALLURE_RESULTS = path.resolve(process.env.ALLURE_RESULTS || './allure-results');
  const ALLURE_REPORT = path.resolve(process.env.ALLURE_REPORT || './allure-report');
  const ALLURE_AUTOOPEN = process.env.ALLURE_AUTOOPEN === 'yes';
  const ALLURE_ZIP = process.env.ALLURE_ZIP === 'yes';
  const PORTABLE_SERVER_PATH = path.resolve('./utils/http-server.exe'); // prebuilt portable server

  try {
    if (IS_ALLURE_ENABLED) {
      console.log(`üìä Generating Allure Report from results at: ${ALLURE_RESULTS}`);

      if (!fs.existsSync(ALLURE_RESULTS)) {
        console.warn(`‚ö†Ô∏è Allure results folder not found: ${ALLURE_RESULTS}`);
        return;
      }

      // ----------------------
      // Backup old report
      // ----------------------
      if (fs.existsSync(ALLURE_REPORT)) {
        const backupParent = path.resolve(path.dirname(ALLURE_REPORT), 'Allure_Backup');
        fs.ensureDirSync(backupParent);

        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const backupReport = path.join(backupParent, `AllureReport_${timestamp}`);

        fs.renameSync(ALLURE_REPORT, backupReport);
        console.log(`üóÇÔ∏è Backed up previous Allure report to: ${backupReport}`);
      }

      // ----------------------
      // Temporary copy results
      // ----------------------
      const tempResults = path.join(path.dirname(ALLURE_REPORT), 'temp-allure-results');
      fs.copySync(ALLURE_RESULTS, tempResults);

      // ----------------------
      // Generate report
      // ----------------------
      execSync(`npx allure generate "${tempResults}" --clean -o "${ALLURE_REPORT}"`, { stdio: 'inherit' });
      console.log(`‚úÖ Allure report generated at: ${ALLURE_REPORT}`);

      // ----------------------
      // Optional: auto-open
      // ----------------------
      if (ALLURE_AUTOOPEN) {
        console.log('üåê Opening Allure report in default browser...');
        execSync(`npx allure open "${ALLURE_REPORT}"`, { stdio: 'inherit' });
      }

      // ----------------------
      // Optional: ZIP with portable server
      // ----------------------
      if (ALLURE_ZIP) {
        const zipOutput = path.resolve('Allure_Report_Package.zip');
        const tempPackage = path.resolve('./temp-allure-package');

        fs.removeSync(tempPackage);
        fs.ensureDirSync(tempPackage);

        // Copy Allure report
        fs.copySync(ALLURE_REPORT, path.join(tempPackage, 'allure-report'));

        // Copy portable server
        if (!fs.existsSync(PORTABLE_SERVER_PATH)) {
          console.warn(`‚ö†Ô∏è Portable server not found at ${PORTABLE_SERVER_PATH}. Skipping ZIP.`);
        } else {
          fs.copySync(PORTABLE_SERVER_PATH, path.join(tempPackage, 'http-server.exe'));

          // Create start-server.bat
          fs.writeFileSync(path.join(tempPackage, 'start-server.bat'), `
@echo off
echo Starting Allure report server...
http-server.exe "allure-report" -p 5000
pause
          `.trim());
        }

        // Create ZIP
        const output = fs.createWriteStream(zipOutput);
        const archive = archiver('zip', { zlib: { level: 9 } });
        archive.pipe(output);
        archive.directory(tempPackage, false);
        await archive.finalize();

        console.log(`üì¶ Interactive Allure package created: ${zipOutput}`);

        // Cleanup temporary package
        fs.removeSync(tempPackage);
      }

      // ----------------------
      // Clean temporary results
      // ----------------------
      fs.removeSync(tempResults);
    }

    console.log('üõ†Ô∏è Global teardown completed!');
  } catch (error) {
    console.error('‚ùå Error in global teardown:', error);
  }
}










