import path from 'path';
import fs from 'fs';
import { getExcelTests } from '../utils/excelReader';
import { getRunList } from '../utils/runListReader';
import { getSuiteList } from '../utils/suiteReader';

const execType = process.env.EXEC_TYPE || 'auto'; // auto = detect best
const suiteName = process.env.SUITE || 'smoke';
const sheetName = process.env.SHEET || 'App1_Login';

console.log(`üöÄ Execution Mode: ${execType}`);

let finalTests: any[] = [];

try {
  if (execType === 'excel' || execType === 'auto') {
    console.log(`üìó Reading Excel Sheet: ${sheetName}`);
    finalTests = getExcelTests(sheetName);
    if (finalTests.length > 0) console.log(`‚úÖ ${finalTests.length} test(s) loaded from Excel`);
  }

  if (finalTests.length === 0 && (execType === 'runlist' || execType === 'auto')) {
    console.log(`üìò Reading runList.json`);
    const runList = getRunList();
    const fileList: any[] = runList.filesToRun || [];
    const testList: any[] = runList.testsToRun || [];
    finalTests = [
      ...fileList.map(file => ({ file })),
      ...testList.flatMap(t => t.tests.map((test: string) => ({ file: t.file, testName: test })))
    ];
    if (finalTests.length > 0) console.log(`‚úÖ ${finalTests.length} test(s) loaded from runList.json`);
  }

  if (finalTests.length === 0 && (execType === 'suite' || execType === 'auto')) {
    console.log(`üìô Reading suite.json for suite: ${suiteName}`);
    const suiteTests = getSuiteList(suiteName);
    finalTests = suiteTests.map(file => ({ file }));
    console.log(`‚úÖ ${finalTests.length} test(s) loaded from suite.json`);
  }

  if (finalTests.length === 0) {
    console.error('‚ùå No test cases found to execute!');
    process.exit(1);
  }

  console.log(`üéØ Final Tests to Run:`);
  finalTests.forEach(t => console.log(` - ${t.file}${t.testName ? ' :: ' + t.testName : ''}`));

  // Execute dynamically
  for (const t of finalTests) {
    const absPath = path.resolve(t.file);
    if (!fs.existsSync(absPath)) {
      console.warn(`‚ö†Ô∏è File not found: ${absPath}`);
      continue;
    }
    require(absPath);
  }

} catch (err: any) {
  console.error('‚ùå Error during test selection:', err.message);
  process.exit(1);
}



import fs from 'fs';
import path from 'path';

export function getSuiteList(suiteName: string) {
  const filePath = path.resolve(__dirname, '../config/suite.json');
  const data = JSON.parse(fs.readFileSync(filePath, 'utf-8'));
  if (!data[suiteName]) throw new Error(`‚ùå Suite '${suiteName}' not found in suite.json`);
  return data[suiteName];
}



import fs from 'fs';
import path from 'path';

export function getRunList() {
  const filePath = path.resolve(__dirname, '../config/runList.json');
  const data = JSON.parse(fs.readFileSync(filePath, 'utf-8'));
  return data;
}



import * as XLSX from 'xlsx';
import path from 'path';

export function getExcelTests(sheetName: string) {
  const filePath = path.resolve(__dirname, '../data/testCases.xlsx');
  const workbook = XLSX.readFile(filePath);
  const sheet = workbook.Sheets[sheetName];
  if (!sheet) throw new Error(`‚ùå Sheet '${sheetName}' not found in Excel`);
  
  const data = XLSX.utils.sheet_to_json(sheet);
  return data
    .filter((row: any) => row.Execute?.toString().toLowerCase() === 'yes')
    .map((row: any) => ({
      appName: row.AppName,
      testCase: row.TestCase,
      file: row.FilePath
    }));
}


{
  "smoke": [
    "tests/app1/login.spec.ts"
  ],
  "regression": [
    "tests/app1/login.spec.ts",
    "tests/app2/report.spec.ts"
  ]
}



{
  "filesToRun": [
    "tests/app1/login.spec.ts"
  ],
  "testsToRun": [
    { "file": "tests/app2/report.spec.ts", "tests": ["Verify Report Generation"] }
  ]
}




// utils/excelReader.ts
import * as XLSX from 'xlsx';
import path from 'path';

export interface ExcelTest {
  file: string;
  name?: string;
}

export function getExcelTests(appName: string, sheetName: string): ExcelTest[] {
  const filePath = path.resolve(__dirname, `../data/${appName}.xlsx`);
  const workbook = XLSX.readFile(filePath);

  // Step 1Ô∏è‚É£: Read the FileMap sheet
  const fileMapSheet = workbook.Sheets['FileMap'];
  if (!fileMapSheet) {
    throw new Error(`‚ùå Missing 'FileMap' sheet in ${appName}.xlsx`);
  }
  const fileMapData = XLSX.utils.sheet_to_json(fileMapSheet);
  const fileMap: Record<string, string> = {};
  for (const row of fileMapData) {
    fileMap[(row as any).SheetName] = (row as any).FilePath;
  }

  // Step 2Ô∏è‚É£: Read the specific module sheet (like 'orders')
  const sheet = workbook.Sheets[sheetName];
  if (!sheet) {
    throw new Error(`‚ùå Sheet '${sheetName}' not found in ${appName}.xlsx`);
  }

  const data = XLSX.utils.sheet_to_json(sheet);
  const moduleFilePath = fileMap[sheetName];

  if (!moduleFilePath) {
    throw new Error(`‚ùå No FilePath mapping found for sheet '${sheetName}' in FileMap`);
  }

  // Step 3Ô∏è‚É£: Filter and map
  return data
    .filter((row: any) => row.Execute?.toString().toLowerCase() === 'yes')
    .map((row: any) => ({
      file: moduleFilePath,
      name: row.TestName
    }));
}


// customTest.ts
import { test as base } from '@playwright/test';
import { getExcelTests } from '../utils/excelReader';
import { getRunListTests } from '../utils/runListReader';
import { getSuiteTests } from '../utils/suiteConfig';

const EXEC_TYPE = process.env.EXEC_TYPE || 'excel';  // excel | runList | suite
const APP = process.env.APP || 'app1';               // workbook name (e.g. app1)
const SHEET = process.env.SHEET || 'login';          // sheet name inside workbook
const SUITE = process.env.SUITE || 'smoke';          // optional (for suite mode)

// Arrays that we‚Äôll populate dynamically
let testsToRun: string[] = [];     // spec file paths
let testNames: string[] = [];      // individual test titles (for Excel filtering)

if (EXEC_TYPE === 'excel') {
  console.log(`üìó Excel Mode ‚Üí App: ${APP}, Sheet: ${SHEET}`);
  const excelTests = getExcelTests(APP, SHEET);
  testsToRun = [...new Set(excelTests.map(t => t.file))];
  testNames = excelTests.map(t => t.name).filter(Boolean);
} 
else if (EXEC_TYPE === 'runList') {
  console.log(`üìò RunList Mode`);
  testsToRun = getRunListTests();
} 
else if (EXEC_TYPE === 'suite') {
  console.log(`üìô Suite Mode ‚Üí Suite: ${SUITE}`);
  testsToRun = getSuiteTests();
}

console.log('üéØ Final Spec Files:', testsToRun);
if (testNames.length > 0) console.log('üß© Filtered Test Names:', testNames);

// ‚úÖ Export Playwright‚Äôs ‚Äútest‚Äù as usual
export const test = base.extend({});

// ‚úÖ Utility function to skip non-selected tests
export const testFilter = (title: string): boolean => {
  if (EXEC_TYPE === 'excel' && testNames.length > 0) {
    return testNames.includes(title);
  }
  return true;
};

// ‚úÖ Optionally export this array if you want custom CLI filtering later
export { testsToRun };



// customTest.ts
import { test as base } from '@playwright/test';
import { getExcelTests } from '../utils/excelReader';
import { getRunListTests } from '../utils/runListReader';
import { getSuiteTests } from '../utils/suiteConfig';

const EXEC_TYPE = process.env.EXEC_TYPE || 'excel';  // excel | runList | suite
const APP = process.env.APP || 'app1';
const SHEET = process.env.SHEET || 'login';
const SUITE = process.env.SUITE || 'smoke';

let testsToRun: string[] = [];
let testNames: string[] = [];

if (EXEC_TYPE === 'excel') {
  console.log(`üìó Excel Mode ‚Üí App: ${APP}, Sheet: ${SHEET}`);
  const excelTests = getExcelTests(APP, SHEET);

  testsToRun = [...new Set(excelTests.map(t => t.file))];

  // ‚úÖ FIXED TYPE ISSUE
  testNames = excelTests
    .map(t => t.name)
    .filter((n): n is string => !!n && n.trim().length > 0);
}
else if (EXEC_TYPE === 'runList') {
  console.log(`üìò RunList Mode`);
  testsToRun = getRunListTests();
}
else if (EXEC_TYPE === 'suite') {
  console.log(`üìô Suite Mode ‚Üí Suite: ${SUITE}`);
  testsToRun = getSuiteTests();
}

console.log('üéØ Final Spec Files:', testsToRun);
if (testNames.length > 0) console.log('üß© Filtered Test Names:', testNames);

export const test = base.extend({});

export const testFilter = (title: string): boolean => {
  if (EXEC_TYPE === 'excel' && testNames.length > 0) {
    return testNames.includes(title);
  }
  return true;
};

export { testsToRun };


import fs from 'fs';
import path from 'path';

interface RunListItem {
  file: string;
  tests?: string[];
}

export function getRunListTests(): RunListItem[] {
  const filePath = path.resolve(__dirname, '../data/runList.json');

  if (!fs.existsSync(filePath)) {
    console.warn(`‚ö†Ô∏è runList.json not found at ${filePath}`);
    return [];
  }

  try {
    const data = JSON.parse(fs.readFileSync(filePath, 'utf-8'));
    if (!Array.isArray(data)) throw new Error('runList.json should be an array');

    return data.map((item: any) => ({
      file: item.file,
      tests: Array.isArray(item.tests) ? item.tests : []
    }));
  } catch (err) {
    console.error(`‚ùå Failed to read runList.json:`, err);
    return [];
  }
}


import { test as base } from '@playwright/test';
import { getRunListTests } from '../utils/runListReader';
import { getExcelTests } from '../utils/excelReader';
import { getSuiteTests } from '../utils/suiteConfig';

const EXEC_TYPE = process.env.EXEC_TYPE || 'excel';
const APP = process.env.APP || 'app1';
const SHEET = process.env.SHEET || 'login';
const SUITE = process.env.SUITE || 'smoke';

let testsToRun: string[] = [];
let testNames: string[] = [];

if (EXEC_TYPE === 'excel') {
  const excelTests = getExcelTests(APP, SHEET);
  testsToRun = [...new Set(excelTests.map(t => t.file))];
  testNames = excelTests.map(t => t.name).filter((n): n is string => !!n && n.trim() !== '');
} 
else if (EXEC_TYPE === 'runList') {
  const runList = getRunListTests(); // array of {file, tests}
  testsToRun = runList.map(item => item.file);
  testNames = runList.flatMap(item => item.tests || []);
} 
else if (EXEC_TYPE === 'suite') {
  testsToRun = getSuiteTests();
}

console.log('üéØ Final Spec Files:', testsToRun);
if (testNames.length > 0) console.log('üß© Filtered Test Names:', testNames);

export const test = base.extend({});

export const testFilter = (title: string) => {
  if (EXEC_TYPE === 'excel' || EXEC_TYPE === 'runList') {
    return testNames.length === 0 || testNames.includes(title);
  }
  return true;
};

export { testsToRun };



